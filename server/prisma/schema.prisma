generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//add customer table to store customer details; will link to users table where customer_id in users table will be the id key in customer table
model customer {
  id                  String   @id @default(uuid())
  name                String   @db.VarChar(255)
  phone               String?  @unique
  address             String?
  city                String?
  state               String?
  zip                 String?
  country             String?
  tax_identifier      String?
  registration_number String?
  website             String?
  created_at          DateTime @db.Date
  updated_at          DateTime @db.Date
  industry            String?
  users               users[]
}

//user table linked to customer table where a user can only belong to one customer
model users {
  id          String           @id @default(uuid())
  username    String           @db.VarChar(30)
  first_name  String           @db.VarChar(30)
  last_name   String           @db.VarChar(30)
  email       String?          @unique
  customer_id String
  created_at  DateTime         @db.Date
  updated_at  DateTime         @db.Date
  password    String
  user_types  user_user_type[]
  tokens      tokens[]
  customers   customer         @relation(fields: [customer_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

//intermediate table to link users and user_type tables
model user_user_type {
  id         Int       @id @default(autoincrement())
  user_id    String
  user_type  String
  users      users     @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user_types user_type @relation(fields: [user_type], references: [type], onDelete: NoAction, onUpdate: NoAction)
}

//user_type table; a user can be more than one type
model user_type {
  id             Int              @id @default(autoincrement())
  type           String           @unique @db.VarChar(30)
  description    String
  created_at     DateTime         @db.Date
  updated_at     DateTime         @db.Date
  user_user_type user_user_type[]
}

//tokens table linked to users table where a user can have multiple tokens
model tokens {
  id             String    @id @default(uuid())
  credentials_id String    @unique
  refresh_token  String?   @unique
  created_at     DateTime? @db.Date
  refreshed_at   DateTime? @db.Date
  provider_id    String?
  user_id        String
  assets         assets[]
  users          users     @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  assetsId       String?
}

//assets table linked to tokens table where a user can have multiple tokens
model assets {
  id           String         @id @default(uuid())
  account_id   String         @unique
  user_id      String
  asset_type   String
  accounts     accounts[]
  tokens       tokens         @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  transactions transactions[]
}

//transactions table linked to assets table where an asset can have multiple transactions
model transactions {
  id                         String   @id @unique
  asset_id                   String
  transaction_id             String   @unique
  transaction_amount         Decimal  @db.Decimal(15, 6)
  transaction_description    String?
  transaction_date           DateTime @db.Date
  transaction_currency       String   @db.VarChar(3)
  transaction_classification String   @db.VarChar(30)
  transaction_category       String   @db.VarChar(30)
  assets                     assets   @relation(fields: [asset_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

//accounts table linked to assets table where an asset can have multiple accounts
model accounts {
  id             String  @id @unique
  asset_id       String
  account_type   String  @db.VarChar(30)
  display_name   String
  description    String?
  currency       String  @db.VarChar(3)
  account_number String?
  iban           String? @db.VarChar(34)
  swift          String? @db.VarChar(11)
  branch_number  String? @db.VarChar(30)
  bank_id        String
  assets         assets  @relation(fields: [asset_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  banks          banks   @relation(fields: [bank_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

//banks table linked to accounts table where an account can only belong to one bank
model banks {
  id        String     @id @default(uuid())
  bank_name String     @db.VarChar(255)
  accounts  accounts[]
}
